#
# This class is automatically generated by mig. DO NOT EDIT THIS FILE.
# This class implements a Python interface to the 'TestNetworkMsg'
# message type.
#

import Message

# The default size of this message type in bytes.
DEFAULT_MESSAGE_SIZE = 48

# The Active Message type associated with this message.
AM_TYPE = 5

class TestNetworkMsg(Message.Message):
    # Create a new TestNetworkMsg of size 48.
    def __init__(self, data="", addr=None, gid=None, base_offset=0, data_length=48):
        Message.Message.__init__(self, data, addr, gid, base_offset, data_length)
        self.amTypeSet(AM_TYPE)
    
    # Get AM_TYPE
    def get_amType(cls):
        return AM_TYPE
    
    get_amType = classmethod(get_amType)
    
    #
    # Return a String representation of this message. Includes the
    # message type name and the non-indexed field values.
    #
    def __str__(self):
        s = "Message <TestNetworkMsg> \n"
        try:
            s += "  [source=0x%x]\n" % (self.get_source())
        except:
            pass
        try:
            s += "  [parents=";
            for i in range(0, 3):
                s += "0x%x " % (self.getElement_parents(i) & 0xffff)
            s += "]\n";
        except:
            pass
        try:
            s += "  [totalParents=0x%x]\n" % (self.get_totalParents())
        except:
            pass
        try:
            s += "  [children=";
            for i in range(0, 3):
                s += "0x%x " % (self.getElement_children(i) & 0xffff)
            s += "]\n";
        except:
            pass
        try:
            s += "  [totalChildren=0x%x]\n" % (self.get_totalChildren())
        except:
            pass
        try:
            s += "  [siblings=";
            for i in range(0, 3):
                s += "0x%x " % (self.getElement_siblings(i) & 0xffff)
            s += "]\n";
        except:
            pass
        try:
            s += "  [totalSiblings=0x%x]\n" % (self.get_totalSiblings())
        except:
            pass
        try:
            s += "  [i_am_primary=0x%x]\n" % (self.get_i_am_primary())
        except:
            pass
        try:
            s += "  [message_type=0x%x]\n" % (self.get_message_type())
        except:
            pass
        try:
            s += "  [self_data1=0x%x]\n" % (self.get_self_data1())
        except:
            pass
        try:
            s += "  [self_data2=0x%x]\n" % (self.get_self_data2())
        except:
            pass
        try:
            s += "  [merged_data=";
            for i in range(0, 5):
                s += "0x%x " % (self.getElement_merged_data(i) & 0xff)
            s += "]\n";
        except:
            pass
        try:
            s += "  [merged_index=";
            for i in range(0, 5):
                s += "0x%x " % (self.getElement_merged_index(i) & 0xff)
            s += "]\n";
        except:
            pass
        try:
            s += "  [childrenReceive=";
            for i in range(0, 3):
                s += "0x%x " % (self.getElement_childrenReceive(i) & 0xff)
            s += "]\n";
        except:
            pass
        try:
            s += "  [childrenHandle=";
            for i in range(0, 3):
                s += "0x%x " % (self.getElement_childrenHandle(i) & 0xff)
            s += "]\n";
        except:
            pass
        try:
            s += "  [curr_num=0x%x]\n" % (self.get_curr_num())
        except:
            pass
        try:
            s += "  [hopcount=0x%x]\n" % (self.get_hopcount())
        except:
            pass
        try:
            s += "  [sendCount=0x%x]\n" % (self.get_sendCount())
        except:
            pass
        try:
            s += "  [sendSuccessCount=0x%x]\n" % (self.get_sendSuccessCount())
        except:
            pass
        return s

    # Message-type-specific access methods appear below.

    #
    # Accessor methods for field: source
    #   Field type: short
    #   Offset (bits): 0
    #   Size (bits): 8
    #

    #
    # Return whether the field 'source' is signed (False).
    #
    def isSigned_source(self):
        return False
    
    #
    # Return whether the field 'source' is an array (False).
    #
    def isArray_source(self):
        return False
    
    #
    # Return the offset (in bytes) of the field 'source'
    #
    def offset_source(self):
        return (0 / 8)
    
    #
    # Return the offset (in bits) of the field 'source'
    #
    def offsetBits_source(self):
        return 0
    
    #
    # Return the value (as a short) of the field 'source'
    #
    def get_source(self):
        return self.getUIntElement(self.offsetBits_source(), 8, 1)
    
    #
    # Set the value of the field 'source'
    #
    def set_source(self, value):
        self.setUIntElement(self.offsetBits_source(), 8, value, 1)
    
    #
    # Return the size, in bytes, of the field 'source'
    #
    def size_source(self):
        return (8 / 8)
    
    #
    # Return the size, in bits, of the field 'source'
    #
    def sizeBits_source(self):
        return 8
    
    #
    # Accessor methods for field: parents
    #   Field type: int[]
    #   Offset (bits): 8
    #   Size of each element (bits): 16
    #

    #
    # Return whether the field 'parents' is signed (False).
    #
    def isSigned_parents(self):
        return False
    
    #
    # Return whether the field 'parents' is an array (True).
    #
    def isArray_parents(self):
        return True
    
    #
    # Return the offset (in bytes) of the field 'parents'
    #
    def offset_parents(self, index1):
        offset = 8
        if index1 < 0 or index1 >= 3:
            raise IndexError
        offset += 0 + index1 * 16
        return (offset / 8)
    
    #
    # Return the offset (in bits) of the field 'parents'
    #
    def offsetBits_parents(self, index1):
        offset = 8
        if index1 < 0 or index1 >= 3:
            raise IndexError
        offset += 0 + index1 * 16
        return offset
    
    #
    # Return the entire array 'parents' as a int[]
    #
    def get_parents(self):
        tmp = [None]*3
        for index0 in range (0, self.numElements_parents(0)):
                tmp[index0] = self.getElement_parents(index0)
        return tmp
    
    #
    # Set the contents of the array 'parents' from the given int[]
    #
    def set_parents(self, value):
        for index0 in range(0, len(value)):
            self.setElement_parents(index0, value[index0])

    #
    # Return an element (as a int) of the array 'parents'
    #
    def getElement_parents(self, index1):
        return self.getUIntElement(self.offsetBits_parents(index1), 16, 1)
    
    #
    # Set an element of the array 'parents'
    #
    def setElement_parents(self, index1, value):
        self.setUIntElement(self.offsetBits_parents(index1), 16, value, 1)
    
    #
    # Return the total size, in bytes, of the array 'parents'
    #
    def totalSize_parents(self):
        return (48 / 8)
    
    #
    # Return the total size, in bits, of the array 'parents'
    #
    def totalSizeBits_parents(self):
        return 48
    
    #
    # Return the size, in bytes, of each element of the array 'parents'
    #
    def elementSize_parents(self):
        return (16 / 8)
    
    #
    # Return the size, in bits, of each element of the array 'parents'
    #
    def elementSizeBits_parents(self):
        return 16
    
    #
    # Return the number of dimensions in the array 'parents'
    #
    def numDimensions_parents(self):
        return 1
    
    #
    # Return the number of elements in the array 'parents'
    #
    def numElements_parents():
        return 3
    
    #
    # Return the number of elements in the array 'parents'
    # for the given dimension.
    #
    def numElements_parents(self, dimension):
        array_dims = [ 3,  ]
        if dimension < 0 or dimension >= 1:
            raise IndexException
        if array_dims[dimension] == 0:
            raise IndexError
        return array_dims[dimension]
    
    #
    # Accessor methods for field: totalParents
    #   Field type: short
    #   Offset (bits): 56
    #   Size (bits): 8
    #

    #
    # Return whether the field 'totalParents' is signed (False).
    #
    def isSigned_totalParents(self):
        return False
    
    #
    # Return whether the field 'totalParents' is an array (False).
    #
    def isArray_totalParents(self):
        return False
    
    #
    # Return the offset (in bytes) of the field 'totalParents'
    #
    def offset_totalParents(self):
        return (56 / 8)
    
    #
    # Return the offset (in bits) of the field 'totalParents'
    #
    def offsetBits_totalParents(self):
        return 56
    
    #
    # Return the value (as a short) of the field 'totalParents'
    #
    def get_totalParents(self):
        return self.getUIntElement(self.offsetBits_totalParents(), 8, 1)
    
    #
    # Set the value of the field 'totalParents'
    #
    def set_totalParents(self, value):
        self.setUIntElement(self.offsetBits_totalParents(), 8, value, 1)
    
    #
    # Return the size, in bytes, of the field 'totalParents'
    #
    def size_totalParents(self):
        return (8 / 8)
    
    #
    # Return the size, in bits, of the field 'totalParents'
    #
    def sizeBits_totalParents(self):
        return 8
    
    #
    # Accessor methods for field: children
    #   Field type: int[]
    #   Offset (bits): 64
    #   Size of each element (bits): 16
    #

    #
    # Return whether the field 'children' is signed (False).
    #
    def isSigned_children(self):
        return False
    
    #
    # Return whether the field 'children' is an array (True).
    #
    def isArray_children(self):
        return True
    
    #
    # Return the offset (in bytes) of the field 'children'
    #
    def offset_children(self, index1):
        offset = 64
        if index1 < 0 or index1 >= 3:
            raise IndexError
        offset += 0 + index1 * 16
        return (offset / 8)
    
    #
    # Return the offset (in bits) of the field 'children'
    #
    def offsetBits_children(self, index1):
        offset = 64
        if index1 < 0 or index1 >= 3:
            raise IndexError
        offset += 0 + index1 * 16
        return offset
    
    #
    # Return the entire array 'children' as a int[]
    #
    def get_children(self):
        tmp = [None]*3
        for index0 in range (0, self.numElements_children(0)):
                tmp[index0] = self.getElement_children(index0)
        return tmp
    
    #
    # Set the contents of the array 'children' from the given int[]
    #
    def set_children(self, value):
        for index0 in range(0, len(value)):
            self.setElement_children(index0, value[index0])

    #
    # Return an element (as a int) of the array 'children'
    #
    def getElement_children(self, index1):
        return self.getUIntElement(self.offsetBits_children(index1), 16, 1)
    
    #
    # Set an element of the array 'children'
    #
    def setElement_children(self, index1, value):
        self.setUIntElement(self.offsetBits_children(index1), 16, value, 1)
    
    #
    # Return the total size, in bytes, of the array 'children'
    #
    def totalSize_children(self):
        return (48 / 8)
    
    #
    # Return the total size, in bits, of the array 'children'
    #
    def totalSizeBits_children(self):
        return 48
    
    #
    # Return the size, in bytes, of each element of the array 'children'
    #
    def elementSize_children(self):
        return (16 / 8)
    
    #
    # Return the size, in bits, of each element of the array 'children'
    #
    def elementSizeBits_children(self):
        return 16
    
    #
    # Return the number of dimensions in the array 'children'
    #
    def numDimensions_children(self):
        return 1
    
    #
    # Return the number of elements in the array 'children'
    #
    def numElements_children():
        return 3
    
    #
    # Return the number of elements in the array 'children'
    # for the given dimension.
    #
    def numElements_children(self, dimension):
        array_dims = [ 3,  ]
        if dimension < 0 or dimension >= 1:
            raise IndexException
        if array_dims[dimension] == 0:
            raise IndexError
        return array_dims[dimension]
    
    #
    # Accessor methods for field: totalChildren
    #   Field type: short
    #   Offset (bits): 112
    #   Size (bits): 8
    #

    #
    # Return whether the field 'totalChildren' is signed (False).
    #
    def isSigned_totalChildren(self):
        return False
    
    #
    # Return whether the field 'totalChildren' is an array (False).
    #
    def isArray_totalChildren(self):
        return False
    
    #
    # Return the offset (in bytes) of the field 'totalChildren'
    #
    def offset_totalChildren(self):
        return (112 / 8)
    
    #
    # Return the offset (in bits) of the field 'totalChildren'
    #
    def offsetBits_totalChildren(self):
        return 112
    
    #
    # Return the value (as a short) of the field 'totalChildren'
    #
    def get_totalChildren(self):
        return self.getUIntElement(self.offsetBits_totalChildren(), 8, 1)
    
    #
    # Set the value of the field 'totalChildren'
    #
    def set_totalChildren(self, value):
        self.setUIntElement(self.offsetBits_totalChildren(), 8, value, 1)
    
    #
    # Return the size, in bytes, of the field 'totalChildren'
    #
    def size_totalChildren(self):
        return (8 / 8)
    
    #
    # Return the size, in bits, of the field 'totalChildren'
    #
    def sizeBits_totalChildren(self):
        return 8
    
    #
    # Accessor methods for field: siblings
    #   Field type: int[]
    #   Offset (bits): 120
    #   Size of each element (bits): 16
    #

    #
    # Return whether the field 'siblings' is signed (False).
    #
    def isSigned_siblings(self):
        return False
    
    #
    # Return whether the field 'siblings' is an array (True).
    #
    def isArray_siblings(self):
        return True
    
    #
    # Return the offset (in bytes) of the field 'siblings'
    #
    def offset_siblings(self, index1):
        offset = 120
        if index1 < 0 or index1 >= 3:
            raise IndexError
        offset += 0 + index1 * 16
        return (offset / 8)
    
    #
    # Return the offset (in bits) of the field 'siblings'
    #
    def offsetBits_siblings(self, index1):
        offset = 120
        if index1 < 0 or index1 >= 3:
            raise IndexError
        offset += 0 + index1 * 16
        return offset
    
    #
    # Return the entire array 'siblings' as a int[]
    #
    def get_siblings(self):
        tmp = [None]*3
        for index0 in range (0, self.numElements_siblings(0)):
                tmp[index0] = self.getElement_siblings(index0)
        return tmp
    
    #
    # Set the contents of the array 'siblings' from the given int[]
    #
    def set_siblings(self, value):
        for index0 in range(0, len(value)):
            self.setElement_siblings(index0, value[index0])

    #
    # Return an element (as a int) of the array 'siblings'
    #
    def getElement_siblings(self, index1):
        return self.getUIntElement(self.offsetBits_siblings(index1), 16, 1)
    
    #
    # Set an element of the array 'siblings'
    #
    def setElement_siblings(self, index1, value):
        self.setUIntElement(self.offsetBits_siblings(index1), 16, value, 1)
    
    #
    # Return the total size, in bytes, of the array 'siblings'
    #
    def totalSize_siblings(self):
        return (48 / 8)
    
    #
    # Return the total size, in bits, of the array 'siblings'
    #
    def totalSizeBits_siblings(self):
        return 48
    
    #
    # Return the size, in bytes, of each element of the array 'siblings'
    #
    def elementSize_siblings(self):
        return (16 / 8)
    
    #
    # Return the size, in bits, of each element of the array 'siblings'
    #
    def elementSizeBits_siblings(self):
        return 16
    
    #
    # Return the number of dimensions in the array 'siblings'
    #
    def numDimensions_siblings(self):
        return 1
    
    #
    # Return the number of elements in the array 'siblings'
    #
    def numElements_siblings():
        return 3
    
    #
    # Return the number of elements in the array 'siblings'
    # for the given dimension.
    #
    def numElements_siblings(self, dimension):
        array_dims = [ 3,  ]
        if dimension < 0 or dimension >= 1:
            raise IndexException
        if array_dims[dimension] == 0:
            raise IndexError
        return array_dims[dimension]
    
    #
    # Accessor methods for field: totalSiblings
    #   Field type: short
    #   Offset (bits): 168
    #   Size (bits): 8
    #

    #
    # Return whether the field 'totalSiblings' is signed (False).
    #
    def isSigned_totalSiblings(self):
        return False
    
    #
    # Return whether the field 'totalSiblings' is an array (False).
    #
    def isArray_totalSiblings(self):
        return False
    
    #
    # Return the offset (in bytes) of the field 'totalSiblings'
    #
    def offset_totalSiblings(self):
        return (168 / 8)
    
    #
    # Return the offset (in bits) of the field 'totalSiblings'
    #
    def offsetBits_totalSiblings(self):
        return 168
    
    #
    # Return the value (as a short) of the field 'totalSiblings'
    #
    def get_totalSiblings(self):
        return self.getUIntElement(self.offsetBits_totalSiblings(), 8, 1)
    
    #
    # Set the value of the field 'totalSiblings'
    #
    def set_totalSiblings(self, value):
        self.setUIntElement(self.offsetBits_totalSiblings(), 8, value, 1)
    
    #
    # Return the size, in bytes, of the field 'totalSiblings'
    #
    def size_totalSiblings(self):
        return (8 / 8)
    
    #
    # Return the size, in bits, of the field 'totalSiblings'
    #
    def sizeBits_totalSiblings(self):
        return 8
    
    #
    # Accessor methods for field: i_am_primary
    #   Field type: short
    #   Offset (bits): 176
    #   Size (bits): 8
    #

    #
    # Return whether the field 'i_am_primary' is signed (False).
    #
    def isSigned_i_am_primary(self):
        return False
    
    #
    # Return whether the field 'i_am_primary' is an array (False).
    #
    def isArray_i_am_primary(self):
        return False
    
    #
    # Return the offset (in bytes) of the field 'i_am_primary'
    #
    def offset_i_am_primary(self):
        return (176 / 8)
    
    #
    # Return the offset (in bits) of the field 'i_am_primary'
    #
    def offsetBits_i_am_primary(self):
        return 176
    
    #
    # Return the value (as a short) of the field 'i_am_primary'
    #
    def get_i_am_primary(self):
        return self.getUIntElement(self.offsetBits_i_am_primary(), 8, 1)
    
    #
    # Set the value of the field 'i_am_primary'
    #
    def set_i_am_primary(self, value):
        self.setUIntElement(self.offsetBits_i_am_primary(), 8, value, 1)
    
    #
    # Return the size, in bytes, of the field 'i_am_primary'
    #
    def size_i_am_primary(self):
        return (8 / 8)
    
    #
    # Return the size, in bits, of the field 'i_am_primary'
    #
    def sizeBits_i_am_primary(self):
        return 8
    
    #
    # Accessor methods for field: message_type
    #   Field type: short
    #   Offset (bits): 184
    #   Size (bits): 8
    #

    #
    # Return whether the field 'message_type' is signed (False).
    #
    def isSigned_message_type(self):
        return False
    
    #
    # Return whether the field 'message_type' is an array (False).
    #
    def isArray_message_type(self):
        return False
    
    #
    # Return the offset (in bytes) of the field 'message_type'
    #
    def offset_message_type(self):
        return (184 / 8)
    
    #
    # Return the offset (in bits) of the field 'message_type'
    #
    def offsetBits_message_type(self):
        return 184
    
    #
    # Return the value (as a short) of the field 'message_type'
    #
    def get_message_type(self):
        return self.getUIntElement(self.offsetBits_message_type(), 8, 1)
    
    #
    # Set the value of the field 'message_type'
    #
    def set_message_type(self, value):
        self.setUIntElement(self.offsetBits_message_type(), 8, value, 1)
    
    #
    # Return the size, in bytes, of the field 'message_type'
    #
    def size_message_type(self):
        return (8 / 8)
    
    #
    # Return the size, in bits, of the field 'message_type'
    #
    def sizeBits_message_type(self):
        return 8
    
    #
    # Accessor methods for field: self_data1
    #   Field type: short
    #   Offset (bits): 192
    #   Size (bits): 8
    #

    #
    # Return whether the field 'self_data1' is signed (False).
    #
    def isSigned_self_data1(self):
        return False
    
    #
    # Return whether the field 'self_data1' is an array (False).
    #
    def isArray_self_data1(self):
        return False
    
    #
    # Return the offset (in bytes) of the field 'self_data1'
    #
    def offset_self_data1(self):
        return (192 / 8)
    
    #
    # Return the offset (in bits) of the field 'self_data1'
    #
    def offsetBits_self_data1(self):
        return 192
    
    #
    # Return the value (as a short) of the field 'self_data1'
    #
    def get_self_data1(self):
        return self.getUIntElement(self.offsetBits_self_data1(), 8, 1)
    
    #
    # Set the value of the field 'self_data1'
    #
    def set_self_data1(self, value):
        self.setUIntElement(self.offsetBits_self_data1(), 8, value, 1)
    
    #
    # Return the size, in bytes, of the field 'self_data1'
    #
    def size_self_data1(self):
        return (8 / 8)
    
    #
    # Return the size, in bits, of the field 'self_data1'
    #
    def sizeBits_self_data1(self):
        return 8
    
    #
    # Accessor methods for field: self_data2
    #   Field type: short
    #   Offset (bits): 200
    #   Size (bits): 8
    #

    #
    # Return whether the field 'self_data2' is signed (False).
    #
    def isSigned_self_data2(self):
        return False
    
    #
    # Return whether the field 'self_data2' is an array (False).
    #
    def isArray_self_data2(self):
        return False
    
    #
    # Return the offset (in bytes) of the field 'self_data2'
    #
    def offset_self_data2(self):
        return (200 / 8)
    
    #
    # Return the offset (in bits) of the field 'self_data2'
    #
    def offsetBits_self_data2(self):
        return 200
    
    #
    # Return the value (as a short) of the field 'self_data2'
    #
    def get_self_data2(self):
        return self.getUIntElement(self.offsetBits_self_data2(), 8, 1)
    
    #
    # Set the value of the field 'self_data2'
    #
    def set_self_data2(self, value):
        self.setUIntElement(self.offsetBits_self_data2(), 8, value, 1)
    
    #
    # Return the size, in bytes, of the field 'self_data2'
    #
    def size_self_data2(self):
        return (8 / 8)
    
    #
    # Return the size, in bits, of the field 'self_data2'
    #
    def sizeBits_self_data2(self):
        return 8
    
    #
    # Accessor methods for field: merged_data
    #   Field type: short[]
    #   Offset (bits): 208
    #   Size of each element (bits): 8
    #

    #
    # Return whether the field 'merged_data' is signed (False).
    #
    def isSigned_merged_data(self):
        return False
    
    #
    # Return whether the field 'merged_data' is an array (True).
    #
    def isArray_merged_data(self):
        return True
    
    #
    # Return the offset (in bytes) of the field 'merged_data'
    #
    def offset_merged_data(self, index1):
        offset = 208
        if index1 < 0 or index1 >= 5:
            raise IndexError
        offset += 0 + index1 * 8
        return (offset / 8)
    
    #
    # Return the offset (in bits) of the field 'merged_data'
    #
    def offsetBits_merged_data(self, index1):
        offset = 208
        if index1 < 0 or index1 >= 5:
            raise IndexError
        offset += 0 + index1 * 8
        return offset
    
    #
    # Return the entire array 'merged_data' as a short[]
    #
    def get_merged_data(self):
        tmp = [None]*5
        for index0 in range (0, self.numElements_merged_data(0)):
                tmp[index0] = self.getElement_merged_data(index0)
        return tmp
    
    #
    # Set the contents of the array 'merged_data' from the given short[]
    #
    def set_merged_data(self, value):
        for index0 in range(0, len(value)):
            self.setElement_merged_data(index0, value[index0])

    #
    # Return an element (as a short) of the array 'merged_data'
    #
    def getElement_merged_data(self, index1):
        return self.getUIntElement(self.offsetBits_merged_data(index1), 8, 1)
    
    #
    # Set an element of the array 'merged_data'
    #
    def setElement_merged_data(self, index1, value):
        self.setUIntElement(self.offsetBits_merged_data(index1), 8, value, 1)
    
    #
    # Return the total size, in bytes, of the array 'merged_data'
    #
    def totalSize_merged_data(self):
        return (40 / 8)
    
    #
    # Return the total size, in bits, of the array 'merged_data'
    #
    def totalSizeBits_merged_data(self):
        return 40
    
    #
    # Return the size, in bytes, of each element of the array 'merged_data'
    #
    def elementSize_merged_data(self):
        return (8 / 8)
    
    #
    # Return the size, in bits, of each element of the array 'merged_data'
    #
    def elementSizeBits_merged_data(self):
        return 8
    
    #
    # Return the number of dimensions in the array 'merged_data'
    #
    def numDimensions_merged_data(self):
        return 1
    
    #
    # Return the number of elements in the array 'merged_data'
    #
    def numElements_merged_data():
        return 5
    
    #
    # Return the number of elements in the array 'merged_data'
    # for the given dimension.
    #
    def numElements_merged_data(self, dimension):
        array_dims = [ 5,  ]
        if dimension < 0 or dimension >= 1:
            raise IndexException
        if array_dims[dimension] == 0:
            raise IndexError
        return array_dims[dimension]
    
    #
    # Fill in the array 'merged_data' with a String
    #
    def setString_merged_data(self, s):
         l = len(s)
         for i in range(0, l):
             self.setElement_merged_data(i, ord(s[i]));
         self.setElement_merged_data(l, 0) #null terminate
    
    #
    # Read the array 'merged_data' as a String
    #
    def getString_merged_data(self):
        carr = "";
        for i in range(0, 4000):
            if self.getElement_merged_data(i) == chr(0):
                break
            carr += self.getElement_merged_data(i)
        return carr
    
    #
    # Accessor methods for field: merged_index
    #   Field type: short[]
    #   Offset (bits): 248
    #   Size of each element (bits): 8
    #

    #
    # Return whether the field 'merged_index' is signed (False).
    #
    def isSigned_merged_index(self):
        return False
    
    #
    # Return whether the field 'merged_index' is an array (True).
    #
    def isArray_merged_index(self):
        return True
    
    #
    # Return the offset (in bytes) of the field 'merged_index'
    #
    def offset_merged_index(self, index1):
        offset = 248
        if index1 < 0 or index1 >= 5:
            raise IndexError
        offset += 0 + index1 * 8
        return (offset / 8)
    
    #
    # Return the offset (in bits) of the field 'merged_index'
    #
    def offsetBits_merged_index(self, index1):
        offset = 248
        if index1 < 0 or index1 >= 5:
            raise IndexError
        offset += 0 + index1 * 8
        return offset
    
    #
    # Return the entire array 'merged_index' as a short[]
    #
    def get_merged_index(self):
        tmp = [None]*5
        for index0 in range (0, self.numElements_merged_index(0)):
                tmp[index0] = self.getElement_merged_index(index0)
        return tmp
    
    #
    # Set the contents of the array 'merged_index' from the given short[]
    #
    def set_merged_index(self, value):
        for index0 in range(0, len(value)):
            self.setElement_merged_index(index0, value[index0])

    #
    # Return an element (as a short) of the array 'merged_index'
    #
    def getElement_merged_index(self, index1):
        return self.getUIntElement(self.offsetBits_merged_index(index1), 8, 1)
    
    #
    # Set an element of the array 'merged_index'
    #
    def setElement_merged_index(self, index1, value):
        self.setUIntElement(self.offsetBits_merged_index(index1), 8, value, 1)
    
    #
    # Return the total size, in bytes, of the array 'merged_index'
    #
    def totalSize_merged_index(self):
        return (40 / 8)
    
    #
    # Return the total size, in bits, of the array 'merged_index'
    #
    def totalSizeBits_merged_index(self):
        return 40
    
    #
    # Return the size, in bytes, of each element of the array 'merged_index'
    #
    def elementSize_merged_index(self):
        return (8 / 8)
    
    #
    # Return the size, in bits, of each element of the array 'merged_index'
    #
    def elementSizeBits_merged_index(self):
        return 8
    
    #
    # Return the number of dimensions in the array 'merged_index'
    #
    def numDimensions_merged_index(self):
        return 1
    
    #
    # Return the number of elements in the array 'merged_index'
    #
    def numElements_merged_index():
        return 5
    
    #
    # Return the number of elements in the array 'merged_index'
    # for the given dimension.
    #
    def numElements_merged_index(self, dimension):
        array_dims = [ 5,  ]
        if dimension < 0 or dimension >= 1:
            raise IndexException
        if array_dims[dimension] == 0:
            raise IndexError
        return array_dims[dimension]
    
    #
    # Fill in the array 'merged_index' with a String
    #
    def setString_merged_index(self, s):
         l = len(s)
         for i in range(0, l):
             self.setElement_merged_index(i, ord(s[i]));
         self.setElement_merged_index(l, 0) #null terminate
    
    #
    # Read the array 'merged_index' as a String
    #
    def getString_merged_index(self):
        carr = "";
        for i in range(0, 4000):
            if self.getElement_merged_index(i) == chr(0):
                break
            carr += self.getElement_merged_index(i)
        return carr
    
    #
    # Accessor methods for field: childrenReceive
    #   Field type: short[]
    #   Offset (bits): 288
    #   Size of each element (bits): 8
    #

    #
    # Return whether the field 'childrenReceive' is signed (False).
    #
    def isSigned_childrenReceive(self):
        return False
    
    #
    # Return whether the field 'childrenReceive' is an array (True).
    #
    def isArray_childrenReceive(self):
        return True
    
    #
    # Return the offset (in bytes) of the field 'childrenReceive'
    #
    def offset_childrenReceive(self, index1):
        offset = 288
        if index1 < 0 or index1 >= 3:
            raise IndexError
        offset += 0 + index1 * 8
        return (offset / 8)
    
    #
    # Return the offset (in bits) of the field 'childrenReceive'
    #
    def offsetBits_childrenReceive(self, index1):
        offset = 288
        if index1 < 0 or index1 >= 3:
            raise IndexError
        offset += 0 + index1 * 8
        return offset
    
    #
    # Return the entire array 'childrenReceive' as a short[]
    #
    def get_childrenReceive(self):
        tmp = [None]*3
        for index0 in range (0, self.numElements_childrenReceive(0)):
                tmp[index0] = self.getElement_childrenReceive(index0)
        return tmp
    
    #
    # Set the contents of the array 'childrenReceive' from the given short[]
    #
    def set_childrenReceive(self, value):
        for index0 in range(0, len(value)):
            self.setElement_childrenReceive(index0, value[index0])

    #
    # Return an element (as a short) of the array 'childrenReceive'
    #
    def getElement_childrenReceive(self, index1):
        return self.getUIntElement(self.offsetBits_childrenReceive(index1), 8, 1)
    
    #
    # Set an element of the array 'childrenReceive'
    #
    def setElement_childrenReceive(self, index1, value):
        self.setUIntElement(self.offsetBits_childrenReceive(index1), 8, value, 1)
    
    #
    # Return the total size, in bytes, of the array 'childrenReceive'
    #
    def totalSize_childrenReceive(self):
        return (24 / 8)
    
    #
    # Return the total size, in bits, of the array 'childrenReceive'
    #
    def totalSizeBits_childrenReceive(self):
        return 24
    
    #
    # Return the size, in bytes, of each element of the array 'childrenReceive'
    #
    def elementSize_childrenReceive(self):
        return (8 / 8)
    
    #
    # Return the size, in bits, of each element of the array 'childrenReceive'
    #
    def elementSizeBits_childrenReceive(self):
        return 8
    
    #
    # Return the number of dimensions in the array 'childrenReceive'
    #
    def numDimensions_childrenReceive(self):
        return 1
    
    #
    # Return the number of elements in the array 'childrenReceive'
    #
    def numElements_childrenReceive():
        return 3
    
    #
    # Return the number of elements in the array 'childrenReceive'
    # for the given dimension.
    #
    def numElements_childrenReceive(self, dimension):
        array_dims = [ 3,  ]
        if dimension < 0 or dimension >= 1:
            raise IndexException
        if array_dims[dimension] == 0:
            raise IndexError
        return array_dims[dimension]
    
    #
    # Fill in the array 'childrenReceive' with a String
    #
    def setString_childrenReceive(self, s):
         l = len(s)
         for i in range(0, l):
             self.setElement_childrenReceive(i, ord(s[i]));
         self.setElement_childrenReceive(l, 0) #null terminate
    
    #
    # Read the array 'childrenReceive' as a String
    #
    def getString_childrenReceive(self):
        carr = "";
        for i in range(0, 4000):
            if self.getElement_childrenReceive(i) == chr(0):
                break
            carr += self.getElement_childrenReceive(i)
        return carr
    
    #
    # Accessor methods for field: childrenHandle
    #   Field type: short[]
    #   Offset (bits): 312
    #   Size of each element (bits): 8
    #

    #
    # Return whether the field 'childrenHandle' is signed (False).
    #
    def isSigned_childrenHandle(self):
        return False
    
    #
    # Return whether the field 'childrenHandle' is an array (True).
    #
    def isArray_childrenHandle(self):
        return True
    
    #
    # Return the offset (in bytes) of the field 'childrenHandle'
    #
    def offset_childrenHandle(self, index1):
        offset = 312
        if index1 < 0 or index1 >= 3:
            raise IndexError
        offset += 0 + index1 * 8
        return (offset / 8)
    
    #
    # Return the offset (in bits) of the field 'childrenHandle'
    #
    def offsetBits_childrenHandle(self, index1):
        offset = 312
        if index1 < 0 or index1 >= 3:
            raise IndexError
        offset += 0 + index1 * 8
        return offset
    
    #
    # Return the entire array 'childrenHandle' as a short[]
    #
    def get_childrenHandle(self):
        tmp = [None]*3
        for index0 in range (0, self.numElements_childrenHandle(0)):
                tmp[index0] = self.getElement_childrenHandle(index0)
        return tmp
    
    #
    # Set the contents of the array 'childrenHandle' from the given short[]
    #
    def set_childrenHandle(self, value):
        for index0 in range(0, len(value)):
            self.setElement_childrenHandle(index0, value[index0])

    #
    # Return an element (as a short) of the array 'childrenHandle'
    #
    def getElement_childrenHandle(self, index1):
        return self.getUIntElement(self.offsetBits_childrenHandle(index1), 8, 1)
    
    #
    # Set an element of the array 'childrenHandle'
    #
    def setElement_childrenHandle(self, index1, value):
        self.setUIntElement(self.offsetBits_childrenHandle(index1), 8, value, 1)
    
    #
    # Return the total size, in bytes, of the array 'childrenHandle'
    #
    def totalSize_childrenHandle(self):
        return (24 / 8)
    
    #
    # Return the total size, in bits, of the array 'childrenHandle'
    #
    def totalSizeBits_childrenHandle(self):
        return 24
    
    #
    # Return the size, in bytes, of each element of the array 'childrenHandle'
    #
    def elementSize_childrenHandle(self):
        return (8 / 8)
    
    #
    # Return the size, in bits, of each element of the array 'childrenHandle'
    #
    def elementSizeBits_childrenHandle(self):
        return 8
    
    #
    # Return the number of dimensions in the array 'childrenHandle'
    #
    def numDimensions_childrenHandle(self):
        return 1
    
    #
    # Return the number of elements in the array 'childrenHandle'
    #
    def numElements_childrenHandle():
        return 3
    
    #
    # Return the number of elements in the array 'childrenHandle'
    # for the given dimension.
    #
    def numElements_childrenHandle(self, dimension):
        array_dims = [ 3,  ]
        if dimension < 0 or dimension >= 1:
            raise IndexException
        if array_dims[dimension] == 0:
            raise IndexError
        return array_dims[dimension]
    
    #
    # Fill in the array 'childrenHandle' with a String
    #
    def setString_childrenHandle(self, s):
         l = len(s)
         for i in range(0, l):
             self.setElement_childrenHandle(i, ord(s[i]));
         self.setElement_childrenHandle(l, 0) #null terminate
    
    #
    # Read the array 'childrenHandle' as a String
    #
    def getString_childrenHandle(self):
        carr = "";
        for i in range(0, 4000):
            if self.getElement_childrenHandle(i) == chr(0):
                break
            carr += self.getElement_childrenHandle(i)
        return carr
    
    #
    # Accessor methods for field: curr_num
    #   Field type: short
    #   Offset (bits): 336
    #   Size (bits): 8
    #

    #
    # Return whether the field 'curr_num' is signed (False).
    #
    def isSigned_curr_num(self):
        return False
    
    #
    # Return whether the field 'curr_num' is an array (False).
    #
    def isArray_curr_num(self):
        return False
    
    #
    # Return the offset (in bytes) of the field 'curr_num'
    #
    def offset_curr_num(self):
        return (336 / 8)
    
    #
    # Return the offset (in bits) of the field 'curr_num'
    #
    def offsetBits_curr_num(self):
        return 336
    
    #
    # Return the value (as a short) of the field 'curr_num'
    #
    def get_curr_num(self):
        return self.getUIntElement(self.offsetBits_curr_num(), 8, 1)
    
    #
    # Set the value of the field 'curr_num'
    #
    def set_curr_num(self, value):
        self.setUIntElement(self.offsetBits_curr_num(), 8, value, 1)
    
    #
    # Return the size, in bytes, of the field 'curr_num'
    #
    def size_curr_num(self):
        return (8 / 8)
    
    #
    # Return the size, in bits, of the field 'curr_num'
    #
    def sizeBits_curr_num(self):
        return 8
    
    #
    # Accessor methods for field: hopcount
    #   Field type: short
    #   Offset (bits): 344
    #   Size (bits): 8
    #

    #
    # Return whether the field 'hopcount' is signed (False).
    #
    def isSigned_hopcount(self):
        return False
    
    #
    # Return whether the field 'hopcount' is an array (False).
    #
    def isArray_hopcount(self):
        return False
    
    #
    # Return the offset (in bytes) of the field 'hopcount'
    #
    def offset_hopcount(self):
        return (344 / 8)
    
    #
    # Return the offset (in bits) of the field 'hopcount'
    #
    def offsetBits_hopcount(self):
        return 344
    
    #
    # Return the value (as a short) of the field 'hopcount'
    #
    def get_hopcount(self):
        return self.getUIntElement(self.offsetBits_hopcount(), 8, 1)
    
    #
    # Set the value of the field 'hopcount'
    #
    def set_hopcount(self, value):
        self.setUIntElement(self.offsetBits_hopcount(), 8, value, 1)
    
    #
    # Return the size, in bytes, of the field 'hopcount'
    #
    def size_hopcount(self):
        return (8 / 8)
    
    #
    # Return the size, in bits, of the field 'hopcount'
    #
    def sizeBits_hopcount(self):
        return 8
    
    #
    # Accessor methods for field: sendCount
    #   Field type: int
    #   Offset (bits): 352
    #   Size (bits): 16
    #

    #
    # Return whether the field 'sendCount' is signed (False).
    #
    def isSigned_sendCount(self):
        return False
    
    #
    # Return whether the field 'sendCount' is an array (False).
    #
    def isArray_sendCount(self):
        return False
    
    #
    # Return the offset (in bytes) of the field 'sendCount'
    #
    def offset_sendCount(self):
        return (352 / 8)
    
    #
    # Return the offset (in bits) of the field 'sendCount'
    #
    def offsetBits_sendCount(self):
        return 352
    
    #
    # Return the value (as a int) of the field 'sendCount'
    #
    def get_sendCount(self):
        return self.getUIntElement(self.offsetBits_sendCount(), 16, 1)
    
    #
    # Set the value of the field 'sendCount'
    #
    def set_sendCount(self, value):
        self.setUIntElement(self.offsetBits_sendCount(), 16, value, 1)
    
    #
    # Return the size, in bytes, of the field 'sendCount'
    #
    def size_sendCount(self):
        return (16 / 8)
    
    #
    # Return the size, in bits, of the field 'sendCount'
    #
    def sizeBits_sendCount(self):
        return 16
    
    #
    # Accessor methods for field: sendSuccessCount
    #   Field type: int
    #   Offset (bits): 368
    #   Size (bits): 16
    #

    #
    # Return whether the field 'sendSuccessCount' is signed (False).
    #
    def isSigned_sendSuccessCount(self):
        return False
    
    #
    # Return whether the field 'sendSuccessCount' is an array (False).
    #
    def isArray_sendSuccessCount(self):
        return False
    
    #
    # Return the offset (in bytes) of the field 'sendSuccessCount'
    #
    def offset_sendSuccessCount(self):
        return (368 / 8)
    
    #
    # Return the offset (in bits) of the field 'sendSuccessCount'
    #
    def offsetBits_sendSuccessCount(self):
        return 368
    
    #
    # Return the value (as a int) of the field 'sendSuccessCount'
    #
    def get_sendSuccessCount(self):
        return self.getUIntElement(self.offsetBits_sendSuccessCount(), 16, 1)
    
    #
    # Set the value of the field 'sendSuccessCount'
    #
    def set_sendSuccessCount(self, value):
        self.setUIntElement(self.offsetBits_sendSuccessCount(), 16, value, 1)
    
    #
    # Return the size, in bytes, of the field 'sendSuccessCount'
    #
    def size_sendSuccessCount(self):
        return (16 / 8)
    
    #
    # Return the size, in bits, of the field 'sendSuccessCount'
    #
    def sizeBits_sendSuccessCount(self):
        return 16
    
